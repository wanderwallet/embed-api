generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("POSTGRES_PRISMA_URL") // uses connection pooling
  directUrl = env("POSTGRES_URL_NON_POOLING") // uses a direct connection
}

enum AuthProviderType {
  PASSKEYS
  EMAIL_N_PASSWORD
  GOOGLE
  FACEBOOK
  X
  APPLE
}

enum NotificationSetting {
  NONE
  SECURITY
  ALL
}

enum FilterPrivacySetting {
  INCLUDE_DETAILS
  HIDE_DETAILS
}

enum Chain {
  ARWEAVE
  ETHEREUM
}

enum WalletStatus {
  ENABLED
  DISABLED
  WATCH_ONLY
  LOST
}

enum WalletPrivacySetting {
  SECRET
  PRIVATE
  PUBLIC
}

enum WalletIdentifierType {
  ALIAS
  ANS
  PNS
}

enum ExportType {
  SEEDPHRASE
  KEYFILE
}

enum ChallengeType {
  HASH
  SIGNATURE
}

enum ChallengePurpose {
  ACTIVATION
  SHARE_RECOVERY
  SHARE_ROTATION
  ACCOUNT_RECOVERY
  ACCOUNT_RECOVERY_CONFIRMATION
}

// TODO: Indexes need to be added manually.

// TODO: Should we add triggers somewhere for cascade updates/deletions?

// TODO: Use VarChar in some fields?

// TODO: Align on models and quickly release API without authentication.

model AuthMethod {
  id            String           @id @default(uuid())
  // TODO: Not sure we need this separate ID. This would come from Auth0. Maybe it can just be the main id on this table.
  providerId    String           @db.VarChar(255)
  providerType  AuthProviderType
  /// This can be an email for EMAIL, a profile handler for social networks or some kind of device ID for passkeys.
  providerLabel String           @db.VarChar(255)
  linkedAt      DateTime         @default(now())
  lastUsedAt    DateTime         @default(now())
  unlinkedAt    DateTime?

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  @@unique([userId, providerId], name: "userAuthentication")
  // TODO: If we end up removing providerId, we can remove this index
  @@index([providerId])
  @@index([lastUsedAt])
  @@map("AuthMethods")
}

model User {
  id        String     @id @default(uuid())
  name      String?    @db.VarChar(100)
  email     String?    @db.VarChar(255)
  developer Developer?

  // Settings:

  /// Receive email notifications for these types of notifications.
  notificationsSetting           NotificationSetting   @default(SECURITY)
  /// Require 1 or more wallet signatures to recover this account.
  recoveryWalletsRequiredSetting Int                   @default(1)
  /// Only allow requests from these IPs.
  ipFilterSetting                String?               @db.VarChar(255)
  /// If a request is rejected due to ipFilterSetting, include or hide the details in the error.
  ipPrivacyFilterSetting         FilterPrivacySetting? @default(HIDE_DETAILS)
  /// Only allow requests from these countries (based in IP).
  // TODO: ISO 3166-1 alpha-2 codes? or should we do alpha-3?
  countryFilterSetting           String?               @db.VarChar(2)
  /// If a request is rejected due to countryFilterSetting, include or hide the details in the error.
  countryPrivacySetting          FilterPrivacySetting? @default(HIDE_DETAILS)

  authMethods         AuthMethod[]
  wallets             Wallet[]
  workKeyShares       WorkKeyShare[]
  recoveryKeyShares   RecoveryKeyShare[]
  challenges          Challenge[]
  devicesAndLocations DeviceAndLocation[]
  Session             Session[]

  @@index([email])
  @@map("Users")
}

model Developer {
  id         Int      @id @default(autoincrement())
  plan       String   @default("free") @db.VarChar(50)
  planPaidAt String   @default("free") @db.VarChar(50)
  apiKey     String   @unique @db.VarChar(255)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @default(now())

  applications Application[]

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String @unique

  @@index([apiKey])
  @@map("Developers")
}

model Application {
  id        String   @id @default(uuid())
  domains   String[] @db.VarChar(255)
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())

  /// Different customization options developers can set in their apps:
  // TODO: Document its shape.
  settings Json

  // Authentication Provider:
  // TODO: We probably need some additional properties from Auth0 or whatever auth provider we use:  
  auth0ClientId String @db.VarChar(255)

  owner             Developer           @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId           Int
  DeviceAndLocation DeviceAndLocation[]
  Session           Session[]

  // TODO: refactor this if we decude to go with another auth provider
  @@index([auth0ClientId])
  @@index([ownerId])
  @@map("Applications")
}

model Wallet {
  id        String       @id @default(uuid())
  /// This must be set to WATCH_ONLY if publicKey is not set.
  status    WalletStatus @default(ENABLED)
  createdAt DateTime     @default(now())
  updatedAt DateTime     @default(now())
  chain     Chain
  address   String       @db.VarChar(255)
  /// Can (not must) be empty for watch-only wallets.
  publicKey String?      @db.VarChar(255)

  // Settings:

  /// Preferred way to visually present this wallet.
  identifierTypeSetting          WalletIdentifierType @default(ALIAS)
  /// Custom description/note the user can attach to this wallet.
  descriptionSetting             String?              @db.VarChar(500)
  /// Custom tags the user can attach to this wallet.
  tagsSetting                    String[]             @db.VarChar(50)
  /// New wallets will prompt the user to backup/export it, but users can disable these reminders (per wallet).
  doNotAskAgainSetting           Boolean              @default(true)
  /// Send the address, only last 4 characters of the address or no address at all when wallets are retrieved.
  walletPrivacySetting           WalletPrivacySetting @default(PUBLIC)
  /// Users will be able to disable wallets as recovery options. This must be set to false if publicKey is not set.
  canRecoverAccountSetting       Boolean              @default(true)
  /// Set to true after the user has exported a seedphrase, private key or recovery file.
  canBeRecovered                 Boolean              @default(false)
  /// Require 1 or more authentication tokens to activate this wallet.
  activationAuthsRequiredSetting Int                  @default(1)
  /// Require 1 or more authentication tokens to backup this wallet (get a recovery share).
  backupAuthsRequiredSetting     Int                  @default(1)
  /// Require 1 or more authentication tokens to recover this wallet.
  recoveryAuthsRequiredSetting   Int                  @default(1)

  /// Includes cached information about how to identify this wallet:
  ///
  /// {
  ///   alias: string;
  ///   ans: string;
  ///   ansResolution: any;
  ///   pns: string;
  ///   pnsResolution: any;
  /// }
  info Json

  /// Information about the origin/source of this wallet:
  /// {
  ///   type "imported" | "generated",
  ///   from: "seedphrase" | "keyfile" | "binary"
  /// }
  source Json

  // TODO: Think about this. We can link to to another model using the deviceNonce, but in that case,
  // when (if) the device nonce is rotated, all these entities must be updated. This might not be a big
  // issue if the deviceNonce is not rotated (only the shares).
  location String @db.VarChar(255)

  // TODO: Do we add them or derive them from the related tables?
  // lastActivatedAt                 DateTime? // From WalletActivation
  // lastBackedUpAt                 DateTime? // From RecoveryKeyShare
  // lastRecoveredAt                 DateTime? // From WalletRecovery
  // lastExportedAt                 DateTime? // From WalletExport

  walletActivations WalletActivation[]
  walletRecoveries  WalletRecovery[]
  walletExports     WalletExport[]
  workKeyShares     WorkKeyShare[]
  recoveryKeyShares RecoveryKeyShare[]
  challenges        Challenge[]

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  @@unique([userId, address, chain], name: "userWallet")
  @@index([address])
  @@index([chain])
  @@index([status])
  @@index([createdAt])
  @@map("Wallets")
}

model WalletActivation {
  id          String   @id @default(uuid())
  activatedAt DateTime @default(now())
  location    String   @db.VarChar(255)

  wallet   Wallet @relation(fields: [walletId], references: [id], onDelete: Cascade)
  walletId String

  workKeyShare   WorkKeyShare @relation(fields: [workKeyShareId], references: [id], onDelete: Cascade)
  workKeyShareId String

  @@index([activatedAt])
  @@map("WalletActivations")
}

model WalletRecovery {
  id          String   @id @default(uuid())
  recoveredAt DateTime @default(now())
  location    String   @db.VarChar(255)

  wallet   Wallet @relation(fields: [walletId], references: [id], onDelete: Cascade)
  walletId String

  recoveryKeyShare   RecoveryKeyShare @relation(fields: [recoveryKeyShareId], references: [id], onDelete: Cascade)
  recoveryKeyShareId String

  @@index([recoveredAt])
  @@map("WalletRecoveries")
}

model WalletExport {
  id         String     @id @default(uuid())
  type       ExportType
  exportedAt DateTime   @default(now())
  location   String     @db.VarChar(255)

  wallet   Wallet @relation(fields: [walletId], references: [id], onDelete: Cascade)
  walletId String

  @@index([exportedAt])
  @@map("WalletExports")
}

/// TODO: Document this
model WorkKeyShare {
  id               String   @id @default(uuid())
  status           String   @db.VarChar(50)
  createdAt        DateTime @default(now())
  sharesRotatedAt  DateTime @default(now())
  rotationWarnings Int      @default(0)

  // TODO: deviceNonce should not rotate and we should actually restore if a device loses it but it still has a
  // device share that we can match. We should replace this with location. If the device share is lost on the device,
  // the shares will also be deleted and force the user to recover them (with a newly generated deviceNonce)
  deviceNonce String @db.VarChar(255)
  location    String @db.VarChar(255)

  authShare            String @db.VarChar(255)
  deviceShareHash      String @db.VarChar(255)
  deviceSharePublicKey String @db.VarChar(255)

  walletActivations WalletActivation[]

  wallet   Wallet @relation(fields: [walletId], references: [id], onDelete: Cascade)
  walletId String

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  /// This unique constraint means that if the users loses the deviceShare but, for whatever reason, not the
  /// device nonce, after requesting the recoveryAuthShare and sending the new authShare and deviceShareHash, this will
  /// replace the previous one (as deviceNonce is the same):
  @@unique([userId, deviceNonce, walletId], name: "deviceWorkShares")
  @@index([status])
  @@index([sharesRotatedAt])
  @@map("WorkKeyShare")
}

/// TODO: Document this
model RecoveryKeyShare {
  id        String   @id @default(uuid())
  status    String   @db.VarChar(50)
  createdAt DateTime @default(now())

  location String @db.VarChar(255)

  recoveryAuthShare            String
  recoveryBackupShareHash      String @db.VarChar(255)
  recoveryBackupSharePublicKey String @db.VarChar(255)

  walletRecoveries WalletRecovery[]

  wallet   Wallet @relation(fields: [walletId], references: [id], onDelete: Cascade)
  walletId String

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  @@index([status])
  @@index([createdAt])
  @@map("RecoveryKeyShare")
}

/// TODO: Document this
/// ACTIVATION =
/// SHARE_RECOVERY =
/// SHARE_ROTATION =
/// ACCOUNT_RECOVERY =
/// ACCOUNT_RECOVERY_CONFIRMATION =
model Challenge {
  id       String           @id @default(uuid())
  type     ChallengeType
  purpose  ChallengePurpose
  value    String           @db.VarChar(255)
  version  String           @db.VarChar(50)
  issuedAt DateTime         @default(now())

  user   User?   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String?

  wallet   Wallet? @relation(fields: [walletId], references: [id], onDelete: Cascade)
  walletId String?

  /// Each user would have up to 5 challenges active at a time (one of each type). Those of the same type will be
  /// overridden.
  @@unique([type, userId], name: "userChallenges")
  @@index([issuedAt])
  @@map("Challenges")
}

/// TODO: Think whether it make sense to have this as an entity and how does affects deviceNonce rotation. If we don't
/// rotate too aggressively, then it makes sense to have it separate, as probably the location entries in Wallet,
/// WorkKeyShare, RecoveryKeyShare and WalletExport might all point to the same row.
///
/// If we rotate too quickly, then each of those steps would already be using a different deviceNonce, creating
/// additional DeviceAndLocation entries.
///
/// We can send back the DeviceAndLocation id and the client can keep sending that one back to us. While
/// no data changes, we keep reusing it. If something changes, we create a new one. If the old one was only
/// linked to WorkKeyShares, then we can actually updated it.
// TODO: Rename to EventInfo?
model DeviceAndLocation {
  id          String   @id @default(uuid())
  createdAt   DateTime @default(now())
  deviceNonce String   @db.VarChar(255)
  // TODO: IPv4 and IPv6? some vpn (cloudflare warp) exposes IPv6 rather than IPv4 if it's specifically set that way
  ip          String   @db.VarChar(45)
  userAgent   String

  application   Application? @relation(fields: [applicationid], references: [id], onDelete: SetNull)
  applicationid String?

  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull)
  userId String?

  @@unique([userId, deviceNonce, ip, userAgent], name: "userDevices")
  @@index([deviceNonce])
  @@index([ip])
  @@index([createdAt])
  @@map("DevicesAndLocations")
}

// TODO: We might want to keep track of when a user logged in on a specific domain (even if wallets are not activated).
model Session {
  id                String   @id @default(uuid())
  providerSessionId String   @db.VarChar(255)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @default(now())
  deviceNonce       String   @db.VarChar(255)
  // TODO: IPv4 and IPv6? some vpn (cloudflare warp) exposes IPv6 rather than IPv4 if it's specifically set that way
  ip                String   @db.VarChar(45)
  userAgent         String   @db.VarChar(500)

  applications Application[]

  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull)
  userId String?

  /// Note how here we don't include ip and userAgent, as we only want to keep one session per user-device, so if the IP
  /// or the userAgent change on the same device, we simply update the session info.
  @@unique([userId, deviceNonce], name: "userSessions")
  @@index([providerSessionId])
  @@index([deviceNonce])
  @@index([ip])
  @@index([updatedAt])
  @@map("Sessions")
}

/// TODO: It seems that the models above already cover all the events we want to log (wallet creation, wallet export...).
/// Would it be preferable to move the location (DeviceAndLocation) of the different events here? Is there any other type
/// of event we might want to log? Should we duplicate it to easily serve both uses cases (showing a log of events and
/// showing the information of a particular event, e.g. where was this wallet created?)?
// model EventLog {
//   id        String   @id @default(uuid())
//   userId    String
//   eventType String   @db.VarChar(100)
//   details   Json
//   createdAt DateTime @default(now())

//   @@index([userId])
//   @@index([eventType])
//   @@index([createdAt])
//   @@map("EventLog")
// }

// TODO: How/where to aggregate data about sessions for analytics to our developers.
