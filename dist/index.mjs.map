{"version":3,"sources":["../sdk/index.ts","../server/utils/error/error.constants.ts","../client/utils/trpc/trpc-client.utils.ts","../client/utils/supabase/supabase-client.utils.ts","../server/utils/challenge/clients/challenge-client-v1-rsa.ts","../server/utils/challenge/clients/challenge-client-v2-eddsa.ts","../server/utils/challenge/clients/challenge-client.utils.ts"],"sourcesContent":["// (DB) Types:\n\nexport type { DbWallet, WalletInfo, WalletSource, RecoverableAccount } from \"@/prisma/types/types\";\n\nexport type {\n  Challenge as DbChallenge,\n  Session as DbSession,\n  UserProfile as DbUserProfile,\n} from \"@prisma/client\";\n\n\n// (DB) Enums:\n\nexport {\n  AuthProviderType,\n  Chain,\n  ExportType,\n  WalletPrivacySetting,\n  WalletSourceFrom,\n  WalletSourceType,\n  WalletStatus,\n} from \"@prisma/client\";\n\n\n// Auth:\n\nexport type { SupabaseSession, SupabaseUser, SupabaseUserMetadata } from \"@/server/utils/supabase/supabase.types\"\nexport type { SupabaseJwtSessionData, SupabaseJwtSessionHeaders, SupabaseProvider, SupabaseJwtPayload } from \"@/server/utils/session/session.types\";\nexport type { AuthError as SupabaseAuthError } from \"@supabase/supabase-js\";\n\n\n// Errors:\n\nexport { ErrorMessages } from \"@/server/utils/error/error.constants\";\n\n\n// Clients:\n\nexport { createTRPCClient } from \"@/client/utils/trpc/trpc-client.utils\";\n\nexport { createSupabaseClient } from \"@/client/utils/supabase/supabase-client.utils\";\n\nexport type { ChallengeClientVersion, ChallengeSolutionWithVersion, ChallengeData, SolveChallengeParams } from \"@/server/utils/challenge/challenge.types\";\nexport { solveChallenge } from \"@/server/utils/challenge/clients/challenge-client.utils\";\nexport { ChallengeClientV1 } from \"@/server/utils/challenge/clients/challenge-client-v1-rsa\";\nexport { ChallengeClientV2 } from \"@/server/utils/challenge/clients/challenge-client-v2-eddsa\";\n\nexport type { AppRouter } from \"@/server/routers/_app\";\n","export const ErrorMessages = {\n  // Wallets:\n  WALLET_NOT_FOUND: `Wallet not found.`,\n  WALLET_CANNOT_BE_ENABLED: `Wallet cannot be enabled.`,\n  WALLET_CANNOT_BE_DISABLED: `Wallet cannot be disabled.`,\n  WALLET_NO_PRIVACY_SUPPORT: \"Wallet does not support the privacy setting.\",\n  WALLET_ADDRESS_MISMATCH: \"Wallet address mismatch.\",\n  WALLET_NOT_VALID_FOR_ACCOUNT_RECOVERY: `Wallet cannot be used for account recovery.`,\n  WALLET_MISSING_PUBLIC_KEY: `Wallet is missing public key.`,\n\n  // Shares:\n  WORK_SHARE_NOT_FOUND: `Work share not found.`,\n  WORK_SHARE_INVALIDATED: `Work share invalidated.`,\n  RECOVERY_SHARE_NOT_FOUND: \"Recovery share not found.\",\n  INVALID_SHARE: `Invalid share.`,\n\n  // Challenge:\n  CHALLENGE_NOT_FOUND: `Challenge not found. It might have been resolved already, or it might have expired.`,\n  CHALLENGE_INVALID: `Invalid challenge.`,\n  CHALLENGE_EXPIRED: `Challenge expired.`,\n  CHALLENGE_IP_MISMATCH: `Challenge IP mismatch.`,\n  CHALLENGE_MISSING_PK: `Missing public key.`,\n  CHALLENGE_UNEXPECTED_ERROR: `Unexpected error validating challenge.`,\n\n  // Recovery:\n  RECOVERY_ACCOUNTS_NOT_FOUND: `No recoverable accounts found.`,\n  RECOVERY_WALLETS_NOT_FOUND: `No recoverable account wallets found.`,\n  RECOVERY_MISSING_PUBLIC_KEY: `Missing public key.`,\n\n  // Generic:\n  NO_OP: \"This request is a no-op.\",\n} as const;\n","import { createTRPCClient as _createTRPCClient, httpBatchLink, TRPCLink } from \"@trpc/client\";\nimport type { AppRouter } from \"@/server/routers/_app\";\nimport superjson from \"superjson\";\nimport { observable } from \"@trpc/server/observable\";\n\nexport interface CreateTRPCClientOptions {\n  baseURL?: string;\n  trpcURL?: string;\n  authToken?: string | null;\n  deviceNonce?: string;\n  clientId?: string;\n  onAuthError?: () => void;\n}\n\ninterface AuthLinkOptions {\n  /**\n   * Callback function to handle authentication errors\n   */\n  onAuthError?: () => void | Promise<void>;\n  /**\n   * Function to get the current auth token\n   */\n  getAuthTokenHeader: () => string | null;\n  /**\n   * Function to set the auth token\n   */\n  setAuthTokenHeader: (token: string | null) => void;\n}\n\nexport const authErrorLink = <TRouter extends AppRouter = AppRouter>(\n  opts: AuthLinkOptions\n): TRPCLink<TRouter> => {\n  return () => {\n    return ({ next, op }) => {\n      return observable((observer) => {\n        const unsubscribe = next(op).subscribe({\n          next(value) {\n            observer.next(value);\n          },\n          async error(err) {\n            if (err.data?.code === \"UNAUTHORIZED\") {\n              console.warn(\"ðŸš« Unauthorized access detected:\", {\n                path: op.path,\n                type: op.type,\n              });\n              const currentAuthToken = opts.getAuthTokenHeader();\n              if (currentAuthToken) {\n                await opts.onAuthError?.();\n                opts.setAuthTokenHeader(null);\n              }\n            }\n            observer.error(err);\n          },\n          complete() {\n            observer.complete();\n          },\n        });\n\n        return unsubscribe;\n      });\n    };\n  };\n};\n\nexport function createTRPCClient({\n  baseURL,\n  trpcURL,\n  onAuthError,\n  ...params\n}: CreateTRPCClientOptions) {\n  let authToken = params.authToken || null;\n  let deviceNonce = params.deviceNonce || \"\";\n  let clientId = params.clientId || \"\";\n\n  function getAuthTokenHeader() {\n    return authToken;\n  }\n\n  function setAuthTokenHeader(nextAuthToken: string | null) {\n    authToken = nextAuthToken || null;\n  }\n\n  function getDeviceNonceHeader() {\n    return deviceNonce;\n  }\n\n  function setDeviceNonceHeader(nextDeviceNonce: string) {\n    deviceNonce = nextDeviceNonce;\n  }\n\n  function getClientIdHeader() {\n    return clientId;\n  }\n\n  function setClientIdHeader(nextClientId: string) {\n    clientId = nextClientId;\n  }\n\n  const url = trpcURL || (baseURL ? `${baseURL.replace(/\\/$/, \"\")}/api/trpc` : \"\");\n\n  if (!url) throw new Error(\"No `baseURL` or `trpcURL` provided.\");\n\n  const client = _createTRPCClient<AppRouter>({\n    links: [\n      authErrorLink({\n        onAuthError,\n        getAuthTokenHeader,\n        setAuthTokenHeader,\n      }),\n      httpBatchLink({\n        url,\n        transformer: superjson,\n        headers() {\n          if (!deviceNonce) {\n            throw new Error(`Missing device nonce header.`);\n          }\n\n          if (!clientId) {\n            throw new Error(`Missing client ID header.`);\n          }\n\n          return {\n            authorization: authToken ? `Bearer ${authToken}` : undefined,\n            \"x-device-nonce\": deviceNonce,\n            \"x-client-id\": clientId,\n          };\n        },\n      }),\n    ],\n  });\n\n  return {\n    client,\n    getAuthTokenHeader,\n    setAuthTokenHeader,\n    getDeviceNonceHeader,\n    setDeviceNonceHeader,\n    getClientIdHeader,\n    setClientIdHeader,\n  };\n}\n","import { SupabaseClientOptions, createClient } from \"@supabase/supabase-js\";\n\nexport function createSupabaseClient(\n  supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || \"\",\n  supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || \"\",\n  supabaseOptions: SupabaseClientOptions<\"public\"> = {\n    auth: {\n      autoRefreshToken: true,\n      persistSession: true,\n      detectSessionInUrl: true,\n    },\n  }\n) {\n  return createClient(supabaseUrl, supabaseKey, supabaseOptions);\n}\n","import {\n  ChallengeClient,\n  ChallengeClientVersion,\n  ChallengeSolutionWithVersion,\n  SolveChallengeParams,\n  VerifyChallengeParams\n} from \"@/server/utils/challenge/challenge.types\";\nimport { getChallengeRawData, isAnonChallenge } from \"@/server/utils/challenge/clients/challenge-client.utils\";\nimport { ErrorMessages } from \"@/server/utils/error/error.constants\";\nimport { ChallengeType } from \"@prisma/client\";\nimport { JWKInterface } from \"arweave/node/lib/wallet\";\nimport { timingSafeEqual } from \"node:crypto\";\n\nconst CHALLENGE_CLIENT_VERSION = \"v1\" as const satisfies ChallengeClientVersion;\n\nconst IMPORT_KEY_ALGORITHM = {\n  name: \"RSA-PSS\",\n  hash: \"SHA-256\",\n} as const satisfies RsaHashedImportParams;\n\nconst SIGN_ALGORITHM = {\n  name: \"RSA-PSS\",\n  saltLength: 32,\n} as const satisfies RsaPssParams;\n\nasync function solveChallenge({\n  challenge,\n  session,\n  shareHash,\n  privateKey: jwk,\n}: SolveChallengeParams<JWKInterface>) {\n  const challengeRawData = getChallengeRawData({\n    challenge,\n    session,\n    shareHash,\n  });\n\n  const challengeRawDataBuffer = Buffer.from(challengeRawData);\n\n  let signatureOrHashBuffer: ArrayBuffer;\n\n  if (\n    isAnonChallenge(challenge) ||\n    challenge.type === ChallengeType.SIGNATURE\n  ) {\n    if (!jwk) {\n      throw new Error(\"Missing private key (jwk)\");\n    }\n\n    const privateKey = await crypto.subtle.importKey(\n      \"jwk\",\n      jwk,\n      IMPORT_KEY_ALGORITHM,\n      true,\n      [\"sign\"]\n    );\n\n    signatureOrHashBuffer = await crypto.subtle.sign(\n      SIGN_ALGORITHM,\n      privateKey,\n      challengeRawDataBuffer\n    );\n  } else if (process.env.NODE_ENV === \"development\") {\n    signatureOrHashBuffer = await crypto.subtle.digest(\n      \"SHA-256\",\n      challengeRawDataBuffer\n    );\n  } else {\n    throw new Error(\"Cannot solve challenge.\");\n  }\n\n  const signatureOrHashString = Buffer.from(signatureOrHashBuffer).toString(\n    \"base64\"\n  );\n\n  return `${CHALLENGE_CLIENT_VERSION}.${signatureOrHashString}` satisfies ChallengeSolutionWithVersion;\n}\n\nasync function verifyChallenge({\n  // ChallengeData:\n  challenge,\n  session,\n  shareHash,\n\n  // Verification:\n  solution,\n  publicKey: publicKeyParam,\n}: VerifyChallengeParams) {\n  const solutionValue = solution.split(\".\")[1];\n\n  if (!solutionValue) {\n    return ErrorMessages.CHALLENGE_UNEXPECTED_ERROR;\n  }\n\n  if (\n    isAnonChallenge(challenge) ||\n    challenge.type === ChallengeType.SIGNATURE\n  ) {\n    // SIGNATURE-BASED CHALLENGE:\n\n    if (!publicKeyParam) {\n      return ErrorMessages.CHALLENGE_MISSING_PK;\n    }\n\n    const publicJWK: JsonWebKey = {\n      e: \"AQAB\",\n      ext: true,\n      kty: \"RSA\",\n      n: publicKeyParam,\n    };\n\n    const publicKey = await crypto.subtle.importKey(\n      \"jwk\",\n      publicJWK,\n      IMPORT_KEY_ALGORITHM,\n      true,\n      [\"verify\"]\n    );\n\n    const challengeRawData = await getChallengeRawData({\n      challenge,\n      session,\n      shareHash,\n    });\n\n    const challengeRawDataBuffer = Buffer.from(challengeRawData);\n\n    const isSignatureValid = crypto.subtle.verify(\n      SIGN_ALGORITHM,\n      publicKey,\n      Buffer.from(solutionValue, \"base64\"),\n      challengeRawDataBuffer\n    );\n\n    if (!isSignatureValid) return ErrorMessages.CHALLENGE_INVALID;\n  } else if (process.env.NODE_ENV === \"development\") {\n    // HASH-BASED CHALLENGES:\n\n    const expectedSolution = await solveChallenge({\n      challenge,\n      session,\n      shareHash,\n    });\n\n    // The length of the solution, excluding the version prefix, should be:\n    //\n    // - 44 characters (String.length) when using a hash.\n    // - 512 bytes (ArrayBuffer.byteLength) when using a signature from a 4096 modulusLength RSA.\n    // - 256 bytes (ArrayBuffer.byteLength) when using a signature from a 2048 modulusLength RSA.\n    // - ...\n    //\n    // However, there's no need to validate that, as we'll be comparing the whole value anyways.\n\n    // Constant-time comparison probably not needed (as we are comparing hashes), but anyway, there's a theatrical\n    // exploit if not doing so. See https://security.stackexchange.com/questions/209807/why-should-password-hash-verification-be-time-constant\n    if (!timingSafeEqual(Buffer.from(expectedSolution, \"utf16le\"), Buffer.from(solution, \"utf16le\"))) return ErrorMessages.CHALLENGE_INVALID;\n  } else {\n    return ErrorMessages.CHALLENGE_UNEXPECTED_ERROR;\n  }\n\n  return null;\n\n}\n\n// This module should also be used on the client as-is.\n// TODO: Remove verifyChallenge function for client use.\n\nexport const ChallengeClientV1: ChallengeClient<JWKInterface> = {\n  version: CHALLENGE_CLIENT_VERSION,\n  getChallengeRawData,\n  solveChallenge,\n  verifyChallenge,\n};\n","import {\n  ChallengeClient,\n  ChallengeClientVersion,\n  ChallengeSolutionWithVersion,\n  SolveChallengeParams,\n  VerifyChallengeParams\n} from \"@/server/utils/challenge/challenge.types\";\nimport { getChallengeRawData, isAnonChallenge } from \"@/server/utils/challenge/clients/challenge-client.utils\";\nimport { ErrorMessages } from \"@/server/utils/error/error.constants\";\nimport { ChallengeType } from \"@prisma/client\";\nimport { ed25519 } from \"@noble/curves/ed25519.js\";\n\nconst CHALLENGE_CLIENT_VERSION = \"v2\" as const satisfies ChallengeClientVersion;\n\nasync function solveChallenge({\n  challenge,\n  session,\n  shareHash,\n  privateKey,\n}: SolveChallengeParams<Uint8Array>) {\n  const challengeRawData = getChallengeRawData({\n    challenge,\n    session,\n    shareHash,\n  });\n\n  const challengeRawDataBuffer = Buffer.from(challengeRawData);\n\n  let signatureBuffer: Uint8Array;\n\n  if (\n    isAnonChallenge(challenge) ||\n    challenge.type === ChallengeType.SIGNATURE\n  ) {\n    if (!privateKey) {\n      throw new Error(\"Missing private key\");\n    }\n\n    /*\n    const privateKey = await crypto.subtle.importKey(\n      \"jwk\",\n      jwk,\n      IMPORT_KEY_ALGORITHM,\n      true,\n      [\"sign\"]\n    );\n\n    signatureOrHashBuffer = await crypto.subtle.sign(\n      SIGN_ALGORITHM,\n      privateKey,\n      challengeRawDataBuffer\n    );\n    */\n\n    // const msg = new Uint8Array(32).fill(1); // message hash (not message) in ecdsa\n    signatureBuffer = ed25519.sign(challengeRawDataBuffer, privateKey); // `{prehash: true}` option is available\n  } else {\n    throw new Error(\"Cannot solve challenge.\");\n  }\n\n  const signatureOrHashString = Buffer.from(signatureBuffer).toString(\n    \"base64\"\n  );\n\n  return `${CHALLENGE_CLIENT_VERSION}.${signatureOrHashString}` satisfies ChallengeSolutionWithVersion;\n}\n\nasync function verifyChallenge({\n  // ChallengeData:\n  challenge,\n  session,\n  shareHash,\n\n  // Verification:\n  solution,\n  publicKey: publicKeyParam,\n}: VerifyChallengeParams) {\n  const solutionValue = solution.split(\".\")[1];\n\n  if (!solutionValue) {\n    return ErrorMessages.CHALLENGE_UNEXPECTED_ERROR;\n  }\n\n  if (\n    isAnonChallenge(challenge) ||\n    challenge.type === ChallengeType.SIGNATURE\n  ) {\n    // SIGNATURE-BASED CHALLENGE:\n\n    if (!publicKeyParam) {\n      return ErrorMessages.CHALLENGE_MISSING_PK;\n    }\n\n    /*\n    const publicJWK: JsonWebKey = {\n      e: \"AQAB\",\n      ext: true,\n      kty: \"RSA\",\n      n: publicKeyParam,\n    };\n\n    const publicKey = await crypto.subtle.importKey(\n      \"jwk\",\n      publicJWK,\n      ChallengeClientV1.importKeyAlgorithm,\n      true,\n      [\"verify\"]\n    );\n    */\n\n    const challengeRawData = await getChallengeRawData({\n      challenge,\n      session,\n      shareHash,\n    });\n\n    const challengeRawDataBuffer = Buffer.from(challengeRawData);\n\n    /*\n    const isSignatureValid = crypto.subtle.verify(\n      ChallengeClientV1.signAlgorithm,\n      publicKey,\n      Buffer.from(solutionValue, \"base64\"),\n      challengeRawDataBuffer\n    );\n    */\n\n    const isSignatureValid = ed25519.verify(\n      Buffer.from(solutionValue, \"base64\"),\n      challengeRawDataBuffer,\n      // TODO: Make sure it is in the right encoding:\n      Buffer.from(publicKeyParam, \"base64\"),\n    );\n\n    if (!isSignatureValid) return ErrorMessages.CHALLENGE_INVALID;\n  } else {\n    return ErrorMessages.CHALLENGE_UNEXPECTED_ERROR;\n  }\n\n  return null;\n\n}\n\n// This module should also be used on the client as-is.\n// TODO: Remove verifyChallenge function for client use.\n\nexport const ChallengeClientV2: ChallengeClient<Uint8Array> = {\n  version: CHALLENGE_CLIENT_VERSION,\n  getChallengeRawData,\n  solveChallenge,\n  verifyChallenge,\n};\n","import { ChallengeClient, ChallengeClientVersion, ChallengeData, SolveChallengeParams } from \"@/server/utils/challenge/challenge.types\";\nimport { ChallengeClientV1 } from \"@/server/utils/challenge/clients/challenge-client-v1-rsa\";\nimport { ChallengeClientV2 } from \"@/server/utils/challenge/clients/challenge-client-v2-eddsa\";\nimport { AnonChallenge, Challenge, ChallengePurpose } from \"@prisma/client\";\nimport { JWKInterface } from \"arweave/node/lib/wallet\";\n\n// We duplicate this function instead of importing it to as `challenge.utils.ts` imports `Config`, which throws an error\n// when imported in the browser:\n\nexport function isAnonChallenge(\n  challenge: Challenge | AnonChallenge\n): challenge is AnonChallenge {\n  return (\n    !!(challenge as AnonChallenge).chain &&\n    !!(challenge as AnonChallenge).address\n  );\n}\n\nconst CHALLENGES_WITHOUT_SHARE_HASH: ChallengePurpose[] = [\n  ChallengePurpose.SHARE_ROTATION,\n  ChallengePurpose.ACCOUNT_RECOVERY,\n  ChallengePurpose.SHARE_RECOVERY,\n];\n\nexport function getChallengeRawData({ challenge, session, shareHash }: ChallengeData) {\n  const commonChallengeData = [\n    challenge.id,\n    challenge.createdAt.toISOString(),\n    challenge.value,\n    challenge.version,\n    session.id,\n    session.deviceNonce,\n    session.userAgent,\n  ].join(\"|\");\n\n  if (isAnonChallenge(challenge)) {\n    return `ANON|${commonChallengeData}|${challenge.chain}|${challenge.address}`;\n  }\n\n  if (\n    !shareHash &&\n    !CHALLENGES_WITHOUT_SHARE_HASH.includes(challenge.purpose)\n  ) {\n    throw new Error(\"Missing `shareHash`\");\n  }\n\n  return [\n    challenge.purpose,\n    commonChallengeData,\n    challenge.userId,\n    challenge.walletId,\n    shareHash,\n  ]\n    .filter(Boolean)\n    .join(\"|\");\n}\n\nexport const CHALLENGE_CLIENTS = [\n  ChallengeClientV1,\n  ChallengeClientV2,\n ].reduce((acc, client) => {\n  if (acc[client.version]) throw new Error(`Duplicate client ${ client.version }`);\n\n  acc[client.version] = client;\n\n  return acc;\n }, {} as Record<ChallengeClientVersion, ChallengeClient<any>>);\n\nexport function solveChallenge({\n  challenge,\n  session,\n  shareHash = null,\n  privateKey,\n}: SolveChallengeParams<JWKInterface | Uint8Array>): Promise<string> {\n  const challengeClient = CHALLENGE_CLIENTS[challenge.version as ChallengeClientVersion];\n\n  console.log(`Solving ${challenge.version} challenge with privateKey =`, privateKey);\n\n  if (!challengeClient) {\n    throw new Error(`Unsupported challenge version: ${challenge.version}`);\n  }\n\n  return challengeClient.solveChallenge({\n    challenge,\n    session,\n    shareHash,\n    privateKey,\n  });\n}\n"],"mappings":";AAaA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;;;ACrBA,IAAM,gBAAgB;AAAA;AAAA,EAE3B,kBAAkB;AAAA,EAClB,0BAA0B;AAAA,EAC1B,2BAA2B;AAAA,EAC3B,2BAA2B;AAAA,EAC3B,yBAAyB;AAAA,EACzB,uCAAuC;AAAA,EACvC,2BAA2B;AAAA;AAAA,EAG3B,sBAAsB;AAAA,EACtB,wBAAwB;AAAA,EACxB,0BAA0B;AAAA,EAC1B,eAAe;AAAA;AAAA,EAGf,qBAAqB;AAAA,EACrB,mBAAmB;AAAA,EACnB,mBAAmB;AAAA,EACnB,uBAAuB;AAAA,EACvB,sBAAsB;AAAA,EACtB,4BAA4B;AAAA;AAAA,EAG5B,6BAA6B;AAAA,EAC7B,4BAA4B;AAAA,EAC5B,6BAA6B;AAAA;AAAA,EAG7B,OAAO;AACT;;;AC/BA,SAAS,oBAAoB,mBAAmB,qBAA+B;AAE/E,OAAO,eAAe;AACtB,SAAS,kBAAkB;AA0BpB,IAAM,gBAAgB,CAC3B,SACsB;AACtB,SAAO,MAAM;AACX,WAAO,CAAC,EAAE,MAAM,GAAG,MAAM;AACvB,aAAO,WAAW,CAAC,aAAa;AAC9B,cAAM,cAAc,KAAK,EAAE,EAAE,UAAU;AAAA,UACrC,KAAK,OAAO;AACV,qBAAS,KAAK,KAAK;AAAA,UACrB;AAAA,UACA,MAAM,MAAM,KAAK;AACf,gBAAI,IAAI,MAAM,SAAS,gBAAgB;AACrC,sBAAQ,KAAK,2CAAoC;AAAA,gBAC/C,MAAM,GAAG;AAAA,gBACT,MAAM,GAAG;AAAA,cACX,CAAC;AACD,oBAAM,mBAAmB,KAAK,mBAAmB;AACjD,kBAAI,kBAAkB;AACpB,sBAAM,KAAK,cAAc;AACzB,qBAAK,mBAAmB,IAAI;AAAA,cAC9B;AAAA,YACF;AACA,qBAAS,MAAM,GAAG;AAAA,UACpB;AAAA,UACA,WAAW;AACT,qBAAS,SAAS;AAAA,UACpB;AAAA,QACF,CAAC;AAED,eAAO;AAAA,MACT,CAAC;AAAA,IACH;AAAA,EACF;AACF;AAEO,SAAS,iBAAiB;AAAA,EAC/B;AAAA,EACA;AAAA,EACA;AAAA,EACA,GAAG;AACL,GAA4B;AAC1B,MAAI,YAAY,OAAO,aAAa;AACpC,MAAI,cAAc,OAAO,eAAe;AACxC,MAAI,WAAW,OAAO,YAAY;AAElC,WAAS,qBAAqB;AAC5B,WAAO;AAAA,EACT;AAEA,WAAS,mBAAmB,eAA8B;AACxD,gBAAY,iBAAiB;AAAA,EAC/B;AAEA,WAAS,uBAAuB;AAC9B,WAAO;AAAA,EACT;AAEA,WAAS,qBAAqB,iBAAyB;AACrD,kBAAc;AAAA,EAChB;AAEA,WAAS,oBAAoB;AAC3B,WAAO;AAAA,EACT;AAEA,WAAS,kBAAkB,cAAsB;AAC/C,eAAW;AAAA,EACb;AAEA,QAAM,MAAM,YAAY,UAAU,GAAG,QAAQ,QAAQ,OAAO,EAAE,CAAC,cAAc;AAE7E,MAAI,CAAC,IAAK,OAAM,IAAI,MAAM,qCAAqC;AAE/D,QAAM,SAAS,kBAA6B;AAAA,IAC1C,OAAO;AAAA,MACL,cAAc;AAAA,QACZ;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC;AAAA,MACD,cAAc;AAAA,QACZ;AAAA,QACA,aAAa;AAAA,QACb,UAAU;AACR,cAAI,CAAC,aAAa;AAChB,kBAAM,IAAI,MAAM,8BAA8B;AAAA,UAChD;AAEA,cAAI,CAAC,UAAU;AACb,kBAAM,IAAI,MAAM,2BAA2B;AAAA,UAC7C;AAEA,iBAAO;AAAA,YACL,eAAe,YAAY,UAAU,SAAS,KAAK;AAAA,YACnD,kBAAkB;AAAA,YAClB,eAAe;AAAA,UACjB;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF,CAAC;AAED,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;;;AC5IA,SAAgC,oBAAoB;AAE7C,SAAS,qBACd,cAAc,QAAQ,IAAI,4BAA4B,IACtD,cAAc,QAAQ,IAAI,iCAAiC,IAC3D,kBAAmD;AAAA,EACjD,MAAM;AAAA,IACJ,kBAAkB;AAAA,IAClB,gBAAgB;AAAA,IAChB,oBAAoB;AAAA,EACtB;AACF,GACA;AACA,SAAO,aAAa,aAAa,aAAa,eAAe;AAC/D;;;ACLA,SAAS,qBAAqB;AAE9B,SAAS,uBAAuB;AAEhC,IAAM,2BAA2B;AAEjC,IAAM,uBAAuB;AAAA,EAC3B,MAAM;AAAA,EACN,MAAM;AACR;AAEA,IAAM,iBAAiB;AAAA,EACrB,MAAM;AAAA,EACN,YAAY;AACd;AAEA,eAAe,eAAe;AAAA,EAC5B;AAAA,EACA;AAAA,EACA;AAAA,EACA,YAAY;AACd,GAAuC;AACrC,QAAM,mBAAmB,oBAAoB;AAAA,IAC3C;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC;AAED,QAAM,yBAAyB,OAAO,KAAK,gBAAgB;AAE3D,MAAI;AAEJ,MACE,gBAAgB,SAAS,KACzB,UAAU,SAAS,cAAc,WACjC;AACA,QAAI,CAAC,KAAK;AACR,YAAM,IAAI,MAAM,2BAA2B;AAAA,IAC7C;AAEA,UAAM,aAAa,MAAM,OAAO,OAAO;AAAA,MACrC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,CAAC,MAAM;AAAA,IACT;AAEA,4BAAwB,MAAM,OAAO,OAAO;AAAA,MAC1C;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF,WAAW,QAAQ,IAAI,aAAa,eAAe;AACjD,4BAAwB,MAAM,OAAO,OAAO;AAAA,MAC1C;AAAA,MACA;AAAA,IACF;AAAA,EACF,OAAO;AACL,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC3C;AAEA,QAAM,wBAAwB,OAAO,KAAK,qBAAqB,EAAE;AAAA,IAC/D;AAAA,EACF;AAEA,SAAO,GAAG,wBAAwB,IAAI,qBAAqB;AAC7D;AAEA,eAAe,gBAAgB;AAAA;AAAA,EAE7B;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAGA;AAAA,EACA,WAAW;AACb,GAA0B;AACxB,QAAM,gBAAgB,SAAS,MAAM,GAAG,EAAE,CAAC;AAE3C,MAAI,CAAC,eAAe;AAClB,WAAO,cAAc;AAAA,EACvB;AAEA,MACE,gBAAgB,SAAS,KACzB,UAAU,SAAS,cAAc,WACjC;AAGA,QAAI,CAAC,gBAAgB;AACnB,aAAO,cAAc;AAAA,IACvB;AAEA,UAAM,YAAwB;AAAA,MAC5B,GAAG;AAAA,MACH,KAAK;AAAA,MACL,KAAK;AAAA,MACL,GAAG;AAAA,IACL;AAEA,UAAM,YAAY,MAAM,OAAO,OAAO;AAAA,MACpC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,CAAC,QAAQ;AAAA,IACX;AAEA,UAAM,mBAAmB,MAAM,oBAAoB;AAAA,MACjD;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AAED,UAAM,yBAAyB,OAAO,KAAK,gBAAgB;AAE3D,UAAM,mBAAmB,OAAO,OAAO;AAAA,MACrC;AAAA,MACA;AAAA,MACA,OAAO,KAAK,eAAe,QAAQ;AAAA,MACnC;AAAA,IACF;AAEA,QAAI,CAAC,iBAAkB,QAAO,cAAc;AAAA,EAC9C,WAAW,QAAQ,IAAI,aAAa,eAAe;AAGjD,UAAM,mBAAmB,MAAM,eAAe;AAAA,MAC5C;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AAaD,QAAI,CAAC,gBAAgB,OAAO,KAAK,kBAAkB,SAAS,GAAG,OAAO,KAAK,UAAU,SAAS,CAAC,EAAG,QAAO,cAAc;AAAA,EACzH,OAAO;AACL,WAAO,cAAc;AAAA,EACvB;AAEA,SAAO;AAET;AAKO,IAAM,oBAAmD;AAAA,EAC9D,SAAS;AAAA,EACT;AAAA,EACA;AAAA,EACA;AACF;;;ACnKA,SAAS,iBAAAA,sBAAqB;AAC9B,SAAS,eAAe;AAExB,IAAMC,4BAA2B;AAEjC,eAAeC,gBAAe;AAAA,EAC5B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAAqC;AACnC,QAAM,mBAAmB,oBAAoB;AAAA,IAC3C;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC;AAED,QAAM,yBAAyB,OAAO,KAAK,gBAAgB;AAE3D,MAAI;AAEJ,MACE,gBAAgB,SAAS,KACzB,UAAU,SAASF,eAAc,WACjC;AACA,QAAI,CAAC,YAAY;AACf,YAAM,IAAI,MAAM,qBAAqB;AAAA,IACvC;AAmBA,sBAAkB,QAAQ,KAAK,wBAAwB,UAAU;AAAA,EACnE,OAAO;AACL,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC3C;AAEA,QAAM,wBAAwB,OAAO,KAAK,eAAe,EAAE;AAAA,IACzD;AAAA,EACF;AAEA,SAAO,GAAGC,yBAAwB,IAAI,qBAAqB;AAC7D;AAEA,eAAeE,iBAAgB;AAAA;AAAA,EAE7B;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAGA;AAAA,EACA,WAAW;AACb,GAA0B;AACxB,QAAM,gBAAgB,SAAS,MAAM,GAAG,EAAE,CAAC;AAE3C,MAAI,CAAC,eAAe;AAClB,WAAO,cAAc;AAAA,EACvB;AAEA,MACE,gBAAgB,SAAS,KACzB,UAAU,SAASH,eAAc,WACjC;AAGA,QAAI,CAAC,gBAAgB;AACnB,aAAO,cAAc;AAAA,IACvB;AAmBA,UAAM,mBAAmB,MAAM,oBAAoB;AAAA,MACjD;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AAED,UAAM,yBAAyB,OAAO,KAAK,gBAAgB;AAW3D,UAAM,mBAAmB,QAAQ;AAAA,MAC/B,OAAO,KAAK,eAAe,QAAQ;AAAA,MACnC;AAAA;AAAA,MAEA,OAAO,KAAK,gBAAgB,QAAQ;AAAA,IACtC;AAEA,QAAI,CAAC,iBAAkB,QAAO,cAAc;AAAA,EAC9C,OAAO;AACL,WAAO,cAAc;AAAA,EACvB;AAEA,SAAO;AAET;AAKO,IAAM,oBAAiD;AAAA,EAC5D,SAASC;AAAA,EACT;AAAA,EACA,gBAAAC;AAAA,EACA,iBAAAC;AACF;;;ACpJA,SAAmC,wBAAwB;AAMpD,SAAS,gBACd,WAC4B;AAC5B,SACE,CAAC,CAAE,UAA4B,SAC/B,CAAC,CAAE,UAA4B;AAEnC;AAEA,IAAM,gCAAoD;AAAA,EACxD,iBAAiB;AAAA,EACjB,iBAAiB;AAAA,EACjB,iBAAiB;AACnB;AAEO,SAAS,oBAAoB,EAAE,WAAW,SAAS,UAAU,GAAkB;AACpF,QAAM,sBAAsB;AAAA,IAC1B,UAAU;AAAA,IACV,UAAU,UAAU,YAAY;AAAA,IAChC,UAAU;AAAA,IACV,UAAU;AAAA,IACV,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,QAAQ;AAAA,EACV,EAAE,KAAK,GAAG;AAEV,MAAI,gBAAgB,SAAS,GAAG;AAC9B,WAAO,QAAQ,mBAAmB,IAAI,UAAU,KAAK,IAAI,UAAU,OAAO;AAAA,EAC5E;AAEA,MACE,CAAC,aACD,CAAC,8BAA8B,SAAS,UAAU,OAAO,GACzD;AACA,UAAM,IAAI,MAAM,qBAAqB;AAAA,EACvC;AAEA,SAAO;AAAA,IACL,UAAU;AAAA,IACV;AAAA,IACA,UAAU;AAAA,IACV,UAAU;AAAA,IACV;AAAA,EACF,EACG,OAAO,OAAO,EACd,KAAK,GAAG;AACb;AAEO,IAAM,oBAAoB;AAAA,EAC/B;AAAA,EACA;AACD,EAAE,OAAO,CAAC,KAAK,WAAW;AACzB,MAAI,IAAI,OAAO,OAAO,EAAG,OAAM,IAAI,MAAM,oBAAqB,OAAO,OAAQ,EAAE;AAE/E,MAAI,OAAO,OAAO,IAAI;AAEtB,SAAO;AACR,GAAG,CAAC,CAAyD;AAEvD,SAASC,gBAAe;AAAA,EAC7B;AAAA,EACA;AAAA,EACA,YAAY;AAAA,EACZ;AACF,GAAqE;AACnE,QAAM,kBAAkB,kBAAkB,UAAU,OAAiC;AAErF,UAAQ,IAAI,WAAW,UAAU,OAAO,gCAAgC,UAAU;AAElF,MAAI,CAAC,iBAAiB;AACpB,UAAM,IAAI,MAAM,kCAAkC,UAAU,OAAO,EAAE;AAAA,EACvE;AAEA,SAAO,gBAAgB,eAAe;AAAA,IACpC;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC;AACH;","names":["ChallengeType","CHALLENGE_CLIENT_VERSION","solveChallenge","verifyChallenge","solveChallenge"]}